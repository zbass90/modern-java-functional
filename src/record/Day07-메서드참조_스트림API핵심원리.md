오늘은 메서드 참조(Method Reference)와 스트림 API의 핵심 원리인**파이프라인 처리와 지연 연산(lazy evaluation)**을 학습했다.

**람다**는 “함수를 값처럼 전달한다”의 개념이라면**메서드 참조**는 그 과정을 더**직관적이고 간결하게 표현하는 도구**다.

---

### **🧩메서드 참조의 4가지 유형**

오늘 배운 메서드 참조는 크게 네 가지로 구분된다.

1. **정적 메서드 참조**–`클래스명::메서드명`

   →`Math::max`,`Integer::parseInt`처럼 클래스의 정적 메서드를 직접 참조한다.

2. **특정 객체의 인스턴스 메서드 참조**–`객체명::메서드명`

   →`person::introduce`,`person::getName`처럼 이미 생성된 객체의 메서드를 참조한다.

3. **생성자 참조**–`클래스명::new`

   →`Person::new`처럼 객체 생성을 함수형으로 표현할 수 있다.

4. **임의 객체의 인스턴스 메서드 참조**–`클래스명::인스턴스메서드명`

   →`(Person p) -> p.introduce()`와 동일하며, 첫 번째 매개변수가 호출 주체가 된다.


특히 마지막 유형은 굉장히 이해가 안되었다. “첫 번째 인자가 메서드를 호출하는 객체가 된다”는 개념이 머리로는 이해돼도, 실제 코드에 적용하려니 감이 잘 잡히지 않았다.

앞으로는 이 부분을 자주 사용해보면서 자연스럽게 익혀야 할 것 같다.

그래도 팁이 있다면,**람다식으로 먼저 풀어서 생각한 뒤 메서드 참조로 바꾸는 연습**을 하면 훨씬 이해가 빠르다고 말씀하셨다.

예를 들어`(Person p) -> p.introduce()`를 떠올리고 나서`Person::introduce`로 전환하는 식이다.

이 과정을 반복하다 보면 “어떤 경우에 메서드 참조를 쓸 수 있는지”가 자연스럽게 몸에 밸 것 같다.

---

### **⚙스트림 API 기본편 학습**

이어서**스트림 API의 기본 구조와 동작 원리**를 학습했다.

스트림은 데이터를**파이프라인(pipeline)**형태로 연결하여 처리하는 완전히 새로운 방식이었다.

```java
List<String> names = List.of("Kim", "Lee", "Park");
names.stream()
     .filter(n -> n.length() <= 3)
     .map(String::toUpperCase)
     .forEach(System.out::println);
```

스트림은 데이터를 한 단계씩 흘려보내며 처리하는데`filter()`,`map()`같은**중간 연산(intermediate operation)**->`forEach()`,`collect()`같은**최종 연산(terminal operation)**을 구분한다.

가장 강력한 점은 스트림이**지연 연산(lazy evaluation)**을 사용한다는 것이었다.

즉, 최종 연산이 호출되기 전까지는 실제 계산이 수행되지 않으며 필요한 데이터만 효율적으로 처리하는**최적화된 동작**을 한다는 점이 앞으로 자주 사용할 것 같다.

또한 이러한 지연 연산이**파이프라인 방식**과 결합되면서 데이터를 한 번만 순회해도 연속적인 변환이 가능하다는 걸 배웠다.

이는 기존의 명령형 코드(for문, if문 중심)보다 훨씬 효율적이고 선언적인 접근 방식이었다.

---

### **💡자네, 무엇을 배웠는가?**

결국 자바 8부터 도입된**Stream API**는 람다를 사용해 선언적이고 간결한 코드를 작성할 수 있을 뿐 아니라,**메서드 참조를 통해 가독성을 높이고****지연 연산과 파이프라인 구조를 통해 성능까지 챙길 수 있는**강력한 기능이었다.

7일차도 완벽히 성공!🚀