오늘은 지난 4일차에서 구현한`filter()`와`map()`메서드를 발전시켜 스트림의 동작 원리를 한땀 한땀 확인했다. 단순히 리스트를 변환하는 데서 끝나지 않고**메서드 체이닝**을 통해 연속적으로 데이터를 변환할 수 있는 구조를 만들어보았다.

이전에는`GenericMapper.map()`처럼 정적 메서드 형태로만 사용했다면, 이번에는`MyStreamV1`클래스를 통해**객체 지향적인 스트림 구조를 설계**했다.

```java
List<Integer> numbers = List.of(1, 2, 3, 4, 5);
List<Integer> result = new MyStreamV1(numbers)
        .filter(n -> n % 2 == 1)
        .map(n -> n * n)
        .toList();

```

이 코드에서 각 메서드는 새로운`MyStreamV1`인스턴스를 반환하고 나아가`filter → map → toList`로 이어지는 유연한 체인 구조를 완성할 수 있었다.

'중간 연산과 최종 연산의 구분'이라는 스트림의 핵심 개념을 직접 눈으로 확인할 수 있었다.

이번 구현은 아직`Integer`중심이었지만 제네릭을 적용하면 훨씬 유연한 스트림 구조로 확장할 수 있다.

특히 각 단계에서 새로운 리스트를 생성하도록 설계해 원본 데이터의 불변성(immutability) 을 지켜냈다는 점이 특별했다.

`new MyStreamV1(filtered)`나`new MyStreamV1(mapped)`처럼 결과를 다시 감싸서 반환하는 방식이 스트림이 내부 상태를 안전하게**캡슐화하는 구조와 동일**하다는 것을 깨닫게 했다.

5일차를 마치며, 이제는 단순히 Stream을 '사용하는 사람'이 아니라

그 구조를 직접 설계하고 구현할 수 있는 수준으로 한 걸음 성장했다는 자신감이 생겼다.

**5일차도 완벽히 성공!**🚀