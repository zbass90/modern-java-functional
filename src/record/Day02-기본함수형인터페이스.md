

오늘은 함수형 인터페이스와 제네릭, 람다의 타겟 타입 그리고 기본 함수형 인터페이스를 집중적으로 공부했다.

먼저 함수형 인터페이스에 제네릭을 적용하는 방법을 살펴보았다. 제네릭을 사용하면 함수형 인터페이스를 더 유연하게 설계할 수 있어, 다양한 타입에 대해 같은 로직을 재사용할 수 있다는 점이 인상적이었다. 특히`Function<T, R>`처럼 입력과 출력 타입을 명시하면, 여러 상황에 대응할 수 있는 재사용 가능한 형태가 된다는 점을 확실히 느꼈다.

이어서는 람다 표현식과 타겟****타입 개념을 정리했다. 람다 자체에는 타입이 없고, 그것이 대입되거나 전달되는 문맥에 따라 어떤 함수형 인터페이스로 해석될지가 달라진다.

```java
Comparator<String> comp = (a, b) -> a.compareTo(b);
```

이 경우 왼쪽의`Comparator<String>`이 타겟 타입이 되어`(a, b)`는 자동으로`String`타입으로 추론된다.

```java
Comparator comp = (a, b) -> a.toString().compareTo(b.toString());
```

반대로 위 처럼 제네릭을 생략하면`Comparator`는 raw type으로 간주되고, 결국`(a, b)`는`Object`타입으로 추론된다. 이 과정을 통해 제네릭을 명시하는 것과 하지 않는 것 사이의 차이를 실감할 수 있었고, 타겟 타입이 어떻게 람다의 실제 타입을 결정하는지를 좀 더 깊게 이해할 수 있었다.

마지막으로`java.util.function`패키지에 포함된 기본 함수형 인터페이스들을 정리했다. 대표적으로`Predicate<T>`,`Consumer<T>`,`Function<T, R>`,`Supplier<T>`,`Runnable`,`UnaryOperator<T>`,`BinaryOperator<T>`등이 있다. 이미 자바 표준 라이브러리에서 대부분 제공하고 있기 때문에, 직접 함수형 인터페이스를 만들 필요가 거의 없다는 점이 실용적으로 다가왔다.

오늘은 함수형 프로그래밍의 뼈대를 이루는 개념들을 서로 연결지어 학습한 하루였다. 단순히 문법을 익히는 수준이 아니라, 제네릭과 람다가 문맥 속에서 어떻게 맞물려 코드의 유연성과 안전성을 동시에 높이는지 감을 잡을 수 있었다.

앞으로 실무 코드에서 이들을 어떻게 적용할 수 있을지 더욱 기대된다.

2일차도 성공적으로 마무리!🚀


